<!DOCTYPE html>
<html lang="pt-BR">
   <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Pesquisa sobre Assincronismo e outros tópicos</title>
      <style>
         body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
         }
         pre {
            background-color: #f4f4f4;
            padding: 10px;
            border: 1px solid #ddd;
            overflow-x: auto;
            border-radius: 5px;
         }

         h1 {
            padding-top: 50px;
         }

         h2,
         h3 {
            color: #ffffff;
            padding: 15px 0;
         }

         p,
         li {
            color: white;
         }
         .section {
            margin-bottom: 40px;
         }
      </style>
      <link rel="stylesheet" href="style.css" />
   </head>
   <body>
      <a href="index.html" class="voltar"
         ><img src="./assets/back.svg" alt=""
      /></a>

      <h1>Pesquisa sobre Assincronismo e outros tópicos</h1>

      <div class="section">
         <h2>A) Assincronismo</h2>
         <p>
            O assincronismo em JavaScript refere-se à capacidade do código de
            rodar operações que não bloqueiam a execução do restante do
            programa. Isso é especialmente útil em tarefas que podem demorar um
            tempo indeterminado para completar, como buscar dados de um servidor
            remoto, ler arquivos de disco ou esperar pela resposta de uma API. A
            principal vantagem de programar de forma assíncrona é que o código
            pode continuar sendo executado enquanto a operação mais demorada
            ainda está sendo processada, melhorando o desempenho e a experiência
            do usuário em aplicações de larga escala.
         </p>

         <h3>1) AJAX (Asynchronous Javascript And XML)</h3>
         <p>
            AJAX é uma técnica usada para criar requisições HTTP para o servidor
            sem a necessidade de recarregar a página inteira. Isso proporciona
            uma experiência de usuário mais fluida e interativa, onde pequenos
            trechos de dados podem ser atualizados dinamicamente sem interromper
            a navegação ou o conteúdo que o usuário está visualizando. A
            tecnologia AJAX foi uma das responsáveis pela evolução do que
            chamamos hoje de aplicações web dinâmicas, permitindo interações
            mais rápidas e eficientes com servidores web.
         </p>
         <pre>
        // Exemplo de requisição AJAX usando jQuery
        $.ajax({
            url: 'https://api.exemplo.com/dados',
            method: 'GET',
            success: function(response) {
                console.log(response);
            }
        });
        </pre
         >

         <h3>2) Promises</h3>
         <p>
            Uma Promise é um objeto em JavaScript que representa a eventual
            conclusão ou falha de uma operação assíncrona. Ela é usada para
            evitar o famoso "callback hell", que ocorre quando há muitas
            operações assíncronas aninhadas em callbacks, resultando em código
            de difícil leitura e manutenção. Promises fornecem uma maneira mais
            limpa de lidar com o fluxo assíncrono, permitindo o uso de
            encadeamento de métodos <code>.then()</code> para processar o
            resultado da operação assim que ela for concluída.
         </p>
         <pre>
// Exemplo de uma promise simples
let minhaPromise = new Promise((resolve, reject) => {
    let sucesso = true;
    
    if (sucesso) {
        resolve("Operação bem-sucedida");
    } else {
        reject("Erro na operação");
    }
});

minhaPromise.then(result => {
    console.log(result);
}).catch(error => {
    console.log(error);
});
        </pre
         >

         <h3>3) Fetch API</h3>
         <p>
            A Fetch API é uma interface moderna baseada em Promises, que fornece
            uma maneira simples e poderosa de fazer requisições HTTP. Ela é uma
            alternativa mais flexível e legível em comparação com o objeto
            XMLHttpRequest, que era amplamente utilizado antes do fetch. Um dos
            principais benefícios da Fetch API é a sua promessa integrada, que
            facilita o tratamento de respostas assíncronas e erros, além de
            oferecer um suporte mais robusto para trabalhar com APIs RESTful.
         </p>
         <pre>
// Exemplo de fetch API
fetch('https://api.exemplo.com/dados')
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error('Erro:', error));
        </pre
         >

         <h3>4) Async/Await</h3>
         <p>
            Async/Await é uma sintaxe introduzida no ECMAScript 2017 que
            simplifica o uso de Promises, tornando o código assíncrono mais
            fácil de ler e escrever. Ao invés de usar encadeamentos de
            <code>.then()</code>, o desenvolvedor pode marcar uma função com a
            palavra-chave <code>async</code> e usar <code>await</code> dentro
            dessa função para pausar sua execução até que a Promise seja
            resolvida. Isso proporciona um código que se parece mais com o
            estilo síncrono, sem comprometer a natureza assíncrona das
            operações.
         </p>
         <pre>
// Exemplo de async/await
async function obterDados() {
    try {
        let response = await fetch('https://api.exemplo.com/dados');
        let data = await response.json();
        console.log(data);
    } catch (error) {
        console.error('Erro:', error);
    }
}

obterDados();
        </pre
         >

         <h3>5) Vantagens/Desvantagens</h3>
         <p><strong>Vantagens:</strong></p>
         <ul>
            <li>
               <strong>AJAX:</strong> Permite interações dinâmicas sem
               recarregar a página, melhorando a experiência do usuário.
            </li>
            <li>
               <strong>Promises:</strong> Proporciona um código mais legível e
               organizado para lidar com assincronismo, evitando o aninhamento
               excessivo de callbacks.
            </li>
            <li>
               <strong>Fetch API:</strong> Simplifica o código para requisições
               HTTP, com suporte nativo para Promises e código mais limpo em
               relação ao XMLHttpRequest.
            </li>
            <li>
               <strong>Async/Await:</strong> Torna o código assíncrono quase tão
               legível quanto o código síncrono, além de facilitar o tratamento
               de erros com <code>try/catch</code>.
            </li>
         </ul>
         <p><strong>Desvantagens:</strong></p>
         <ul>
            <li>
               <strong>AJAX:</strong> Embora poderoso, pode aumentar a
               complexidade do código em casos de muitas requisições
               simultâneas.
            </li>
            <li>
               <strong>Promises:</strong> Apesar de melhorar o código, ainda
               pode levar a problemas de legibilidade em situações com muitas
               operações encadeadas.
            </li>
            <li>
               <strong>Fetch API:</strong> Não trata automaticamente respostas
               HTTP com erros (status 4xx ou 5xx), sendo necessário lidar com
               isso manualmente.
            </li>
            <li>
               <strong>Async/Await:</strong> Exige um bom entendimento de
               Promises e do modelo assíncrono do JavaScript para ser usado
               corretamente.
            </li>
         </ul>
      </div>

      <div class="section">
         <h2>B) Outros tópicos</h2>

         <h3>1) Hoisting</h3>
         <p>
            O hoisting é um comportamento do JavaScript em que variáveis e
            funções declaradas são "movidas" para o topo do escopo antes da
            execução do código. Isso significa que é possível acessar uma
            variável antes de sua declaração, embora, no caso de variáveis, o
            valor retornado seja <code>undefined</code> até que a inicialização
            seja realizada. O hoisting pode levar a comportamentos inesperados e
            é uma característica importante a ser entendida para evitar bugs,
            especialmente quando se utiliza <code>var</code> para declarar
            variáveis.
         </p>
         <pre>
// Exemplo de hoisting
console.log(nome); // undefined
var nome = "João";
        </pre
         >

         <h3>2) Arrow Functions</h3>
         <p>
            Arrow functions são uma maneira mais concisa de escrever funções em
            JavaScript, introduzidas no ES6. Além da sintaxe reduzida, elas
            diferem das funções tradicionais porque não possuem seu próprio
            contexto <code>this</code>. Isso significa que o valor de
            <code>this</code> em uma arrow function é o mesmo que no contexto
            onde ela foi criada, o que é útil para evitar problemas ao acessar
            métodos de objetos dentro de funções. Arrow functions são amplamente
            usadas em operações de callback e em métodos de array, como
            <code>map()</code> e <code>filter()</code>.
         </p>
         <pre>
// Exemplo de Arrow Function
const somar = (a, b) => a + b;
console.log(somar(5, 3)); // 8
        </pre
         >

         <h3>3) Desestruturação (Destructuring)</h3>
         <p>
            A desestruturação permite extrair valores de arrays ou propriedades
            de objetos e atribuí-los a variáveis de maneira mais simples e
            direta. Introduzida no ES6, essa sintaxe facilita a manipulação de
            objetos complexos e arrays sem a necessidade de acessar cada
            propriedade ou índice individualmente. A desestruturação pode ser
            utilizada tanto em arrays quanto em objetos, sendo uma poderosa
            ferramenta para reduzir a quantidade de código e melhorar a
            legibilidade.
         </p>
         <pre>
// Exemplo de desestruturação de objeto
const pessoa = { nome: "Maria", idade: 25 };
const { nome, idade } = pessoa;
console.log(nome); // Maria
console.log(idade); // 25
        </pre
         >

         <h3>4) Closure</h3>
         <p>
            Closures são uma característica importante do JavaScript. Um closure
            é formado quando uma função interna "lembra" do escopo no qual foi
            criada, mesmo depois desse escopo ter sido finalizado. Isso permite
            que funções internas acessem variáveis da função externa, mesmo após
            a execução da função externa ter terminado. Closures são usados
            frequentemente em programação funcional e em padrões como
            <code>module pattern</code> para manter variáveis privadas dentro de
            uma função.
         </p>
         <pre>
// Exemplo de closure
function saudacao(nome) {
    let mensagem = "Olá, " + nome;
    return function() {
        console.log(mensagem);
    }
}

const saudacaoParaJoao = saudacao("João");
saudacaoParaJoao(); // Olá, João
        </pre
         >
      </div>
   </body>
</html>
